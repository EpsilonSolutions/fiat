module TRANSPARENT_ABSTRACT =
  struct
    open Tacticals.New
    open Tacmach.New
    open Proofview.Notations

    (* Transparently abstract the goal *)
    let transparent_abstract_by_tac id tac gk =
      Proofview.Goal.nf_s_enter
	{ s_enter =
	    begin fun gl ->
		  let sigma = Proofview.Goal.sigma gl in
		  let current_sign = Global.named_context()
		  and global_sign = Proofview.Goal.hyps gl in
		  let sigma = Sigma.to_evar_map sigma in
		  let evdref = ref sigma in
		  (* Identify which hypotheses are local and which are section variables. *)
		  let sign, secsign =
		    List.fold_right
		      (fun d (s1, s2) ->
		       let id = get_id d in
		       if mem_named_context id current_sign &&
			    interpretable_as_section_decl evdref (Context.Named.lookup id current_sign) d
		       then (s1,push_named_context_val d s2)
		       else (Context.Named.add d s1,s2))
		      global_sign (Context.Named.empty, empty_named_context_val) in
		  (* Build the identifier for the new term *)
		  let id = next_global_ident_away id (pf_ids_of_hyps gl) in
		  (* Construct the type of the term by abstracting over the *)
		  (* local hypotheses and definitions. *)
		  let concl = it_mkNamedProd_or_LetIn (Proofview.Goal.concl gl) sign in
		  (* Make sure there are no uninstantiated evars in the type of the target. *)
		  let concl =
		    try flush_and_check_evars !evdref concl
		    with Uninstantiated_evar _ ->
		      error "\"abstract\" cannot handle existentials." in
		  (* ?? *)
		  let evd, ctx, concl =
		    (* FIXME: should be done only if the tactic succeeds *)
		    let evd, nf = nf_evars_and_universes !evdref in
		    let ctx = Evd.universe_context_set evd in
		    evd, ctx, nf concl
		  in
		  (* This is the tactic script that should solve the goal. *)
		  let solve_tac = tclCOMPLETE (tclTHEN (tclDO (List.length sign) intro) tac) in
		  (* Get the universe context associated with the evar map [evd] *)
		  let ectx = Evd.evar_universe_context evd in
		  let (const, safe, ectx) =
		    (* Actually build the constant using [solve_tac] *)
		    try Pfedit.build_constant_by_tactic ~goal_kind:gk id ectx secsign concl solve_tac
		    with Logic_monad.TacticFailure e as src ->
		      (* if the tactic [tac] fails, it reports a [TacticFailure e], *)
		      (* which is an error irrelevant to the proof system (in fact it *)
		      (* means that [e] comes from [tac] failing to yield enough *)
		      (* success). Hence it reraises [e]. *)
		      let (_, info) = Errors.push src in
		      iraise (e, info)
		  in
		  let const, args =
		    (* Default behavior is to create constants that are only *)
		    (* quantified over the hypotheses they depend on. *)
		    shrink_entry sign const
				 (* Otherwise use the following line*)
				 (*(const, List.rev (Context.Named.to_instance sign))*)
		  in
		  (* Create a global definition for const *)
		  let cd = Entries.DefinitionEntry const in
		  let decl = (cd, IsDefinition Definition) in
		  (** bendy: Seems okay for new constant to be local, but may have unintended **)
		  (** consequences if abstracted terms should be accessed outside the proof. **)
		  let cst = Declare.declare_constant ~internal:Declare.InternalTacticRequest ~local:true id decl in
		  (* Tactic Monad *)
		  let df, ctx = Universes.unsafe_constr_of_global (ConstRef cst) in
		  (* Universe Variable stuff? *)
		  let evd = Evd.set_universe_context evd ectx in
		  let open Safe_typing in
		  (* Build a private constant for the new constant *)
		  let eff = private_con_of_con (Global.safe_env ()) cst in
		  (* Add that constant to the private constants *)
		  let effs = add_private eff
					 Entries.(snd (Future.force const.const_entry_body)) in
		  (* Use the definition built above to solve the goal. *)
		  let solve =
		    Proofview.tclEFFECTS effs <*>
		      new_exact_no_check (applist (df, args))
		  in
		  let tac = if not safe then Proofview.mark_as_unsafe <*> solve else solve in
		  (* Build our sigma *)
		  Sigma.Unsafe.of_pair (tac, evd)
	    end }

    let tclABSTRACT2 name_op tac =
      let open Proof_global in
      let default_gk = (Global, false, Proof Theorem) in
      let s, gk = match name_op with
	| Some s ->
	   (try let _, gk, _ = current_proof_statement () in s, gk
	    with NoCurrentProof -> s, default_gk)
	| None   ->
	   let name, gk =
	     try let name, gk, _ = current_proof_statement () in name, gk
	     with NoCurrentProof -> anon_id, default_gk in
	   add_suffix name "_term", gk
      in
      transparent_abstract_by_tac s tac gk

  end

    (*let tclABSTRACT2 name_op tac gl =
    let s = match name_op with
      | Some s -> s
      | None   -> Nameops.add_suffix (Pfedit.get_current_proof_name ()) "_term"
    in *)


    (*  let tclABSTRACTTERM name_op term tacK gl =
    let s = match name_op with
      | Some s -> s
      | None   -> Nameops.add_suffix (Pfedit.get_current_proof_name ()) "_term"
    in
    transparent_abstract_term s term tacK gl

end

  TACTIC EXTEND abstracttermas
  | [ "cache_term" constr(term) "as" ident(name) "run" tactic(tacK)]  ->
     [ fun gl -> TRANSPARENT_ABSTRACT.tclABSTRACTTERM (Some name) term tacK gl ]
       END

  TACTIC EXTEND abstractterm
  | [ "cache_term" constr(term) "run" tactic(tacK) ]  ->
     [ fun gl -> TRANSPARENT_ABSTRACT.tclABSTRACTTERM None term tacK gl ]
       END *)

    TACTIC EXTEND transparentabstract
  | [ "cache" tactic(tac) "as" ident(name)]  ->
     [ fun gl -> TRANSPARENT_ABSTRACT.tclABSTRACT2 (Some name) tac gl ]
       END;;
