(** * Definition of the finite set spec *)Require Import Coq.Strings.String Coq.Sets.Ensembles Coq.Sets.Finite_sets Coq.Lists.List Coq.Sorting.Permutation.Require Import ADTSynthesis.ADT ADTSynthesis.ADT.ComputationalADT ADTSynthesis.ADTRefinement.Core ADTSynthesis.ADTNotation ADTSynthesis.ADTRefinement.GeneralRefinements ADTSynthesis.Common.AdditionalEnsembleDefinitions.Require Export ADTSynthesis.FiniteSetADTs.FiniteSetADT.Require Import Coq.MSets.MSetInterface Coq.MSets.MSetAVL.Set Implicit Arguments.Local Open Scope string_scope.Module BedrockWordAsOrderedType <: OrderedType.  Definition t : Type := W.  Definition eq : t -> t -> Prop := eq.  Definition eq_equiv : Equivalence eq := _.  Definition lt : t -> t -> Prop := fun x y => wlt x y = true.  Definition lt_strorder : StrictOrder lt.  Proof.    constructor; lazy; intros.    { rewrite ?wlt_irrefl in *; try congruence. }    { eapply wlt_trans; eassumption. }  Qed.  Definition lt_compat : Proper (eq ==> eq ==> iff) lt.  Proof.    lazy; repeat intro; subst; tauto.  Qed.  Definition compare : t -> t -> comparison    := fun x y => if wlt x y                  then Lt                  else if wlt y x                       then Gt                       else Eq.  Definition compare_spec :    forall x y : t, CompareSpec (eq x y) (lt x y) (lt y x) (compare x y).  Proof.    lazy; intros x y.    case_eq (wlt x y); case_eq (wlt y x); intros;    constructor; trivial.    eapply wle_antisym; eassumption.  Qed.  Definition eq_dec : forall x y : t, {eq x y} + {~ eq x y}.  Proof.    refine (fun x y            => (if weq x y as weqxy return weq x y = weqxy -> _                then fun H => left (proj2 (weq_iff x y) H)                else fun H => right _)                 eq_refl);    abstract (lazy; intros; subst;              pose proof (proj1 (weq_iff y y) eq_refl);              congruence).  Defined.End BedrockWordAsOrderedType.Module FiniteSetADTMSet (FSMSet : SetsOn BedrockWordAsOrderedType).  Local Notation mkMethod idx :=    (cMethodType FSMSet.t (fst (MethodDomCod FiniteSetSig {| bindex := idx |}))                 (snd (MethodDomCod FiniteSetSig {| bindex := idx |}))).  Definition FiniteSetCImpl_Empty  : cConstructorType FSMSet.t (ConstructorDom FiniteSetSig {| bindex := "Empty" |})    := fun _ => FSMSet.empty.  Definition FiniteSetCImpl_Add : mkMethod "Add"    := fun fs w => (FSMSet.add w fs, tt).  Definition FiniteSetCImpl_Remove : mkMethod "Remove"    := fun fs w => (FSMSet.remove w fs, tt).  Definition FiniteSetCImpl_In : mkMethod "In"    := fun fs w => (fs, FSMSet.mem w fs).  Definition FiniteSetCImpl_Size : mkMethod "Size"    := fun fs w => (fs, FSMSet.cardinal fs).  Definition FiniteSetCImpl : cADT FiniteSetSig.  Proof.    exists FSMSet.t.    admit.    admit.  Defined.  Local Ltac handle_computes_to_step_t :=    idtac;    match goal with      | _ => intro      | _ => progress simpl in *      | _ => progress destruct_head_hnf prod      | _ => progress destruct_head_hnf unit      | [ |- computes_to (Bind _ _) _ ] => refine (BindComputes _ _ _)      | [ |- computes_to (Return _) _ ] => refine (ReturnComputes _)      | [ |- computes_to (Pick _) _ ] => refine (PickComputes _ _ _)    end.  Local Ltac t_step :=    idtac;    match goal with      | _ => progress repeat handle_computes_to_step_t      | _ => progress destruct_head_hnf Empty_set      | _ => progress destruct_head_hnf or      | _ => progress destruct_head_hnf Union      | _ => progress destruct_head_hnf Singleton      | _ => progress destruct_head_hnf prod      | _ => progress destruct_head_hnf unit      | _ => progress destruct_head_hnf False      | _ => progress inversion_by computes_to_inv      | _ => progress subst      | _ => progress unfold Ensembles.In, Same_set, Included, Subtract, Setminus in *      | _ => progress simplify_hyps      | [ H : (_, _) = (_, _) |- _ ] => inversion H; clear H      | [ |- Empty_set _ _ ] => exfalso      | [ |- Singleton _ _ _ ] => constructor      | [ H : FSMSet.In _ FSMSet.empty |- _ ] => apply FSMSet.empty_spec in H      | [ |- FSMSet.In _ (FSMSet.add _ _) ] => apply FSMSet.add_spec      | [ H : FSMSet.In _ (FSMSet.add _ _) |- _ ] => apply FSMSet.add_spec in H      | [ |- FSMSet.In _ (FSMSet.remove _ _) ] => apply FSMSet.remove_spec      | [ H : FSMSet.In _ (FSMSet.remove _ _) |- _ ] => apply FSMSet.remove_spec in H      | _ => rewrite FSMSet.cardinal_spec      | [ |- cardinal _ _ _ ] => eexists      | [ |- Datatypes.length _ = Datatypes.length _ ] => reflexivity      | [ |- EnsembleListEquivalence _ _ ] => split      | [ |- NoDup (FSMSet.elements _) ] => eapply NoDupA_NoDup; [ | apply FSMSet.elements_spec2w ]; try exact _      | [ |- In _ (FSMSet.elements _) ] => apply InA_In_eq      | [ |- InA _ _ (FSMSet.elements _) ] => apply FSMSet.elements_spec1      | [ H : In _ (FSMSet.elements _) |- _ ] => apply InA_In_eq in H      | [ H : InA _ _ (FSMSet.elements _) |- _ ] => apply FSMSet.elements_spec1 in H      | [ |- FSMSet.mem _ _ = true ] => apply FSMSet.mem_spec      | [ H : FSMSet.mem _ _ = true |- _ ] => apply FSMSet.mem_spec in H      | [ H : ~Singleton _ ?x ?x |- _ ] => exfalso; apply H; clear      | [ |- _ /\ _ ] => split      | [ |- _ <-> _ ] => split      | [ |- ?G ] => not has_evar G; solve [ eauto with nocore ]      | [ |- ?G ] => not has_evar G; left; reflexivity      | [ |- ?G ] => not has_evar G; right; reflexivity      | [ |- ?G ] => not has_evar G; right; solve [ hnf; eauto with nocore ]      | [ |- ?G ] => not has_evar G; left; solve [ hnf; eauto with nocore ]    end.  Local Ltac t := repeat repeat t_step.  Lemma FiniteSetImpl_Empty  : refineConstructor      (fun (S0 : Ensemble FSMSet.elt) (fs : FSMSet.t) =>         Same_set FSMSet.elt S0 (fun w : FSMSet.elt => FSMSet.In w fs))      (Constructors FiniteSetSpec {| bindex := "Empty" |})      (fun d => ret (FiniteSetCImpl_Empty d)).  Proof.    unfold FiniteSetCImpl_Empty; t.  Qed.  Lemma FiniteSetImpl_Add  : refineMethod      (fun (S0 : Ensemble FSMSet.elt) (fs : FSMSet.t) =>         Same_set FSMSet.elt S0 (fun w : FSMSet.elt => FSMSet.In w fs))      (Methods FiniteSetSpec {| bindex := "Add" |})      (fun fs x => ret (FiniteSetCImpl_Add fs x)).  Proof.    unfold FiniteSetCImpl_Add; t.  Qed.  Lemma FiniteSetImpl_Remove  : refineMethod      (fun (S0 : Ensemble FSMSet.elt) (fs : FSMSet.t) =>         Same_set FSMSet.elt S0 (fun w : FSMSet.elt => FSMSet.In w fs))      (Methods FiniteSetSpec {| bindex := "Remove" |})      (fun fs x => ret (FiniteSetCImpl_Remove fs x)).  Proof.    unfold FiniteSetCImpl_Remove; t.  Qed.  Lemma FiniteSetImpl_In  : refineMethod      (fun (S0 : Ensemble FSMSet.elt) (fs : FSMSet.t) =>         Same_set FSMSet.elt S0 (fun w : FSMSet.elt => FSMSet.In w fs))      (Methods FiniteSetSpec {| bindex := "In" |})      (fun fs x => ret (FiniteSetCImpl_In fs x)).  Proof.    unfold FiniteSetCImpl_In; t.  Qed.  Lemma FiniteSetImpl_Size  : refineMethod      (fun (S0 : Ensemble FSMSet.elt) (fs : FSMSet.t) =>         Same_set FSMSet.elt S0 (fun w : FSMSet.elt => FSMSet.In w fs))      (Methods FiniteSetSpec {| bindex := "Size" |})      (fun fs x => ret (FiniteSetCImpl_Size fs x)).  Proof.    unfold FiniteSetCImpl_Size; t.  Qed.  Definition FiniteSetImpl : FullySharpened FiniteSetSpec.  Proof.    exists FiniteSetCImpl.    exists (fun S0 fs => Same_set _ S0 (fun w => FSMSet.In w fs)).    admit.    admit.  Defined.End FiniteSetADTMSet.Module MSetAVL_BedrockWord := MSetAVL.Make BedrockWordAsOrderedType.Module Export FiniteSetADTMSetAVL := FiniteSetADTMSet MSetAVL_BedrockWord.